import java.nio.file.Files
import java.nio.file.StandardCopyOption
import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar


//region GLOBALS
buildscript {
    //dependencies versions/modules
    ext.kotlin_version = "1.3.72"

    //JRE bundling
    ext.jreVersion = "13"
    ext.operatingSystems = ["windows/x64","linux/x64","mac/x64"] //adoptopenjdk API v3

    //javaFX
    ext.javafx_version = "14"
    ext.javafx_modules = ['javafx-base', 'javafx-graphics', 'javafx-controls', 'javafx-fxml' ]
    ext.javafx_platforms = ['win','linux','mac']


}

//endregion
//region PLUGINS / REPOSITORIES
plugins {
    //basic things
    id "application"
    id "org.jetbrains.kotlin.jvm" version "$kotlin_version"

    //JAR plugin
    id 'com.github.johnrengelman.shadow' version '6.0.0'

    //JRE bundling plugins
    id 'edu.sc.seis.launch4j' version '2.4.6'
    id "nebula.ospackage" version "8.4.1"
    id "edu.sc.seis.macAppBundle" version "2.3.0"
}

repositories {
    mavenLocal()
    mavenCentral()
    jcenter()
    maven {
        url "https://oss.sonatype.org/content/repositories/snapshots/"
    }
}
//endregion

mainClassName = "com.gitnarwhal.MainKt"
version = "0.0.1"

//region COMPILATION/DEPENDENCIES
compileKotlin.kotlinOptions.jvmTarget = jreVersion

def javafx_dependencies_per_platform = javafx_platforms.collectEntries{ platform->
    [(platform) : (javafx_modules.collect{ module ->
        "org.openjfx:$module:$javafx_version:$platform"
    })]
}

dependencies {
    implementation "org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"
    implementation 'org.kordamp.ikonli:ikonli-javafx:11.5.0'
    implementation 'org.kordamp.ikonli:ikonli-materialdesign-pack:11.5.0'


    javafx_dependencies_per_platform.each { platform, deps ->
        deps.each { dependency ->
            implementation(dependency)
        }
    }
}
//endregion

//region FAT/JAR
jar.enabled(false)
shadowJar {
    archiveBaseName = project.name
    archiveClassifier = ''
    archiveVersion  = project.version

    manifest {
        attributes(
                "Main-Class": mainClassName,
                "Specification-Version" : project.version
        )
    }
}
//endregion

task release {
    dependsOn shadowJar
    dependsOn createExe
}

createExe{
    dependsOn shadowJar
    mainClassName = project.mainClassName
    outfile = project.name + ".exe"
    jar = "lib/"+tasks.jar.archiveFileName.get()
    icon = projectDir.absolutePath + "/icon.ico"


    doFirst{
        launch4j.bundledJrePath = downloadJRE("windows/x64", jreVersion)
    }
}

task exe{
    doLast {
        Files.createDirectories(new File(buildDir.absolutePath+"/exe").toPath())
        Files.createDirectories(new File(buildDir.absolutePath+"/jars").toPath())
        copy {
            from downloadJRE("windows/x64", jreVersion)
            into buildDir.absolutePath+"/exe/jre"
        }
        copy{
            from libsDirectory
            into buildDir.absolutePath+"/exe/jars"
        }
        PrintWriter out = new PrintWriter(buildDir.absolutePath+"/exe/"+project.name+".bat")
        out.println('START %~dp0/jre/bin/javaw.exe -jar %~dp0/jars/'+jar.archiveFileName.get());
        out.close()
    }
}

//region HELPERS FUNCTIONS
static String downloadFileWithRedirects(String location, String path ) {
    HttpURLConnection connection = null;
    String redirectLocation = "";
    String lastValidFileName = "temp.zip"
    for (;;) {
        println("URL: "+ location)
        location.eachMatch("([.a-zA-Z0-9-_]*\\.[.a-zA-Z]{3,})\$"){match->
            lastValidFileName = match[0]
        }
        URL url = new URL(location);
        connection = (HttpURLConnection) url.openConnection();
        connection.setInstanceFollowRedirects(false);
        redirectLocation = connection.getHeaderField("Location");
        if (redirectLocation == null) break;
        location = redirectLocation;
    }

    println("FOUND: "+lastValidFileName)

    String fileName = path + '/' + lastValidFileName
    new File(fileName).withOutputStream { out ->
        new URL(location).openConnection().inputStream.with { inp ->
            out << inp
            inp.close()
        }
    }
    return fileName
}

def String downloadJRE(String operatingSystem, String jreVersion) {
    def jrePath = buildDir.absolutePath + "/jre/" + jreVersion + "/" + operatingSystem

    if (new File(jrePath).isDirectory()){
        //println("JRE "+jreVersion+" FOR "+operatingSystem+" already present, not downloading it again.")
        return jrePath
    }

    println("JRE "+jreVersion+" FOR "+operatingSystem+" MISSING, downloading it...")

    def tempDir = new File(buildDir.absolutePath + "/jre/temp");
    if(tempDir.exists()) tempDir.deleteDir()
    Files.createDirectories(tempDir.toPath())

    def downloaded = downloadFileWithRedirects("https://api.adoptopenjdk.net/v3/binary/latest/"+jreVersion+"/ga/"+operatingSystem+"/jre/hotspot/normal/adoptopenjdk", tempDir.path)

    //EXTRACT IT
    if(downloaded.endsWith(".zip")){
        copy {
            from zipTree(downloaded)
            into tempDir
        }
    }else if(downloaded.endsWith(".tar.gz")){
        copy {
            from tarTree(resources.gzip(downloaded))
            into tempDir
        }
    }

    //IF EXTRACTION DIDN'T WORK
    new File(downloaded).delete()
    def files = tempDir.listFiles()
    if(files.size() != 1){
        throw new Exception("JRE DOWNLOAD ERROR!");
    }

    //MOVE IT TO THE RIGHT LOCATION
    def copyTarget = new File(jrePath)
    Files.createDirectories(copyTarget.parentFile.toPath())
    Files.move(files[0].toPath(), copyTarget.toPath(), StandardCopyOption.REPLACE_EXISTING)

    println("JRE "+jreVersion+" FOR "+operatingSystem+" downloaded!");
    return jrePath
}
//endregion